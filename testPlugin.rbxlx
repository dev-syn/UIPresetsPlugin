<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX1EDDAE790F6141778C55269EFBEF3725">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AvatarUnificationMode">0</token>
			<token name="CSGAsyncDynamicCollision">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBX8C336E3341B9422796F077ECF5368662</Ref>
			<token name="DecreaseMinimumPartDensityMode">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingBehavior">0</token>
			<token name="ModelStreamingMode">0</token>
			<token name="MoverConstraintRootBehavior">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PathfindingUseImprovedSearch">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="RenderingCacheOptimizations">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior2">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000002</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBX8C336E3341B9422796F077ECF5368662">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>113.591492</X>
					<Y>-13.4879141</Y>
					<Z>10.6914749</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>-0</R02>
					<R10>-0</R10>
					<R11>0.780868351</R11>
					<R12>0.624695659</R12>
					<R20>0</R20>
					<R21>-0.624695659</R21>
					<R22>0.780868351</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>113.591492</X>
					<Y>-14.7373056</Y>
					<Z>9.12973785</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f000000003</UniqueId>
				<bool name="VRTiltAndRollEnabled">false</bool>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXCFA299033CD2442487F9E7DB17FA9801">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="GrassLength">0.699999988</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<bool name="ShorelinesUpgraded">true</bool>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f000000378</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXFACE4BE136C7406388EAFCF4F3584EB2">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="DefaultListenerLocation">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000030f</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBX79671CC1BDB2465A93943B7927BB512C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000310</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBXE212D20DF28B4D789687D45FBC43A557">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000311</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX5D23B7EE49E941F0B47140EF6F4F9E8A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000312</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXA19D26EC50B54CC98F17AC43A974C2E0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000317</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX818245DB2D4341F5BE5AEEE7FB12D4B5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TimerService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000030e</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX3A80F38514E54AF2903F90F44424D276">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CharacterAutoLoads">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000319</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBXF04A688329E944329D01751D52FC42F3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000031c</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX2EA9D91354B54C69BB48717ECA7F4D3F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000031e</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX4664455B98F341E08541BF9305E35E22">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<bool name="DefinesCapabilities">false</bool>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000031f</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX04DB6B068A8B4B7EACBCE29FC1F4EB2C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000320</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX6B050B653C0147C2A5938C8F4F290B42">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f00000037b</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBXB1DCFB7522084713823CF94123E56C5A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="KeyboardKeyCode">47</token>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f00000037c</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBXA2EE323973A546E8BD19A04ABC0710B5">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f00000037d</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX3BEE20A3562644818D23F023D1DFFACC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000324</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXEEBC9850CE244F3EA2EE1B57812E0CD3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CustomPoliciesEnabled">false</bool>
			<bool name="DefinesCapabilities">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<int name="TextElongationFactor">0</int>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000326</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX4ACD9D45F6394F378A55D776369D56CA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000032a</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBXCDE88058B11B4F21A6BBF41B359E7A9A">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_Serialized">0</token>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<bool name="DefinesCapabilities">false</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000032c</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBXD17E2EFF047C44C5876E26076B5C166E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f000000379</UniqueId>
			</Properties>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX023E57098636422F883226C65EFCC8E2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f00000037a</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXC3B6D055118A4D61ABBF417BE7A816A7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000032d</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX3DB22A855BAD4BCAA001B12B2808728F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000032e</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
		<Item class="ScreenGui" referent="RBXF559CF2BAD1F4850A6DA519F6AF0A41E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="ClipToDeviceSafeArea">true</bool>
				<bool name="DefinesCapabilities">false</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">UIPresetsPlugin</string>
				<bool name="ResetOnSpawn">true</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<token name="SafeAreaCompatibility">1</token>
				<token name="ScreenInsets">2</token>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f00000643c</UniqueId>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBX81BD6EE3DFF341E2ADF99F5E9B7DEFE3">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>0.5</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.180392161</R>
						<G>0.180392161</G>
						<B>0.180392161</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="ClipsDescendants">false</bool>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Draggable">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">PluginFrame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.25</XS>
						<XO>0</XO>
						<YS>0.699999988</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7889031309ed50d5060a27f00000643d</UniqueId>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBXDB2FAE11C7284578B99D3015F7C2F276">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.180392161</R>
							<G>0.180392161</G>
							<B>0.180392161</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">UIPresetsBG</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00008811</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX5CFF614B8F4B42108DCF2CB26EBDDAC8">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.180392161</R>
								<G>0.180392161</G>
								<B>0.180392161</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Content</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.75</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00008812</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBXE1D5838BEE554C2594118A90F777E290">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.180392161</R>
									<G>0.180392161</G>
									<B>0.180392161</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">NavItem-Main</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00008813</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBX7BCF748E0DB84DE9B09182D0FBAF8605">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.152941182</R>
										<G>0.152941182</G>
										<B>0.152941182</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Content</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.899999976</XS>
										<XO>0</XO>
										<YS>0.899999976</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00008814</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBXFD136A360BD34FADB15F12D2593EB1CA">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.211764723</R>
								<G>0.211764723</G>
								<B>0.211764723</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/DenkOne.json</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Title</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<string name="OpenTypeFeatures"></string>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.0199999996</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.699999988</XS>
								<XO>0</XO>
								<YS>0.0649999976</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">UIPresets</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c0000881b</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UICorner" referent="RBX4FB2F66233D442EF842C950D353C851A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<UDim name="CornerRadius">
									<S>0.400000006</S>
									<O>0</O>
								</UDim>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c0000881c</UniqueId>
							</Properties>
						</Item>
						<Item class="UITextSizeConstraint" referent="RBX848D44B350B54CED8795F45EB2124A41">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<int name="MaxTextSize">28</int>
								<int name="MinTextSize">12</int>
								<string name="Name">UITextSizeConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000073a4</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXDDEA57FF64304A53A35B558FE896497A">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.219607845</R>
								<G>0.219607845</G>
								<B>0.219607845</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">NavbarBG</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c0000881d</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ScrollingFrame" referent="RBXE077CBD90DE143C4AAC090D5B3D2BE48">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">1</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.129411772</R>
									<G>0.129411772</G>
									<B>0.129411772</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<token name="HorizontalScrollBarInset">1</token>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">Navbar</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0</float>
								<int name="ScrollBarThickness">7</int>
								<token name="ScrollingDirection">1</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.899999976</XS>
									<XO>0</XO>
									<YS>0.800000012</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c0000881e</UniqueId>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextButton" referent="RBX723C52FA081A47EFBB440151A8A5D941">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.219607845</R>
										<G>0.219607845</G>
										<B>0.219607845</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/PressStart2P.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">ComponentsBtn</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.400000006</XS>
										<XO>0</XO>
										<YS>0.699999988</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Components</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c0000881f</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UITextSizeConstraint" referent="RBXA62EA2FF6FCF443FBCD66C24901A2F74">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<int name="MaxTextSize">20</int>
										<int name="MinTextSize">14</int>
										<string name="Name">UITextSizeConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00008820</UniqueId>
									</Properties>
								</Item>
								<Item class="UIAspectRatioConstraint" referent="RBX1F0FBBC684C94F88B83A7F8C7AAAB0D5">
									<Properties>
										<float name="AspectRatio">2.5</float>
										<token name="AspectType">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="DominantAxis">1</token>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIAspectRatioConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c0000888e</UniqueId>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBX65AF5335AA0A40ED94C855A71C9277B7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIPadding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>0</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000073a3</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBXA453A0976F7C4277933F28F569B7772C">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.219607845</R>
										<G>0.219607845</G>
										<B>0.219607845</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/PressStart2P.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">PresetsBtn</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.400000006</XS>
										<XO>0</XO>
										<YS>0.699999988</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Presets</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00008821</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UITextSizeConstraint" referent="RBX21386D427C0A46108AB0AE954940C4E2">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<int name="MaxTextSize">20</int>
										<int name="MinTextSize">14</int>
										<string name="Name">UITextSizeConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c000088b0</UniqueId>
									</Properties>
								</Item>
								<Item class="UIAspectRatioConstraint" referent="RBXE5C59F71F33144409EC484E5ECDA64AD">
									<Properties>
										<float name="AspectRatio">2.5</float>
										<token name="AspectType">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="DominantAxis">1</token>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIAspectRatioConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c000088af</UniqueId>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBXCA812D4CA1104312B7573AA2F898AA04">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIPadding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>0</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000073a2</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBXD359C6058E8A40939ABE3F81B1A14801">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<UniqueId name="HistoryId">4665e33cded9312a070d123c00007c8e</UniqueId>
									<token name="HorizontalAlignment">0</token>
									<token name="HorizontalFlex">4</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0.100000001</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00008823</UniqueId>
									<token name="VerticalAlignment">0</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBX4B5F5789E7C445C781B9CD0D41F80159">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">true</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.180392161</R>
								<G>0.180392161</G>
								<B>0.180392161</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=6031280882</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<bool name="Modal">false</bool>
							<string name="Name">SettingsBtn</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.959999979</XS>
								<XO>0</XO>
								<YS>0.0149999997</YS>
								<YO>0</YO>
							</UDim2>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00008824</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIAspectRatioConstraint" referent="RBX2F8B354DB47A449FB84B8287546B8DBA">
							<Properties>
								<float name="AspectRatio">1</float>
								<token name="AspectType">1</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<token name="DominantAxis">1</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UIAspectRatioConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000073a1</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX0023E84C0DF74B38A813B524FBFB22D0">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>0.5</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.298039228</R>
						<G>0.298039228</G>
						<B>0.298039228</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="ClipsDescendants">false</bool>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Draggable">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">MenuElement</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.200000003</XS>
						<XO>0</XO>
						<YS>0.600000024</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4665e33cded9312a070d123c00008ac0</UniqueId>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX98722081C1644C9CBDC9B8766147BE41">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>1</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.258823544</R>
							<G>0.258823544</G>
							<B>0.258823544</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Content</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.870000005</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00008bc5</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBXB683611F4B90405C821FC506F73BD9A8">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.258823544</R>
							<G>0.258823544</G>
							<B>0.258823544</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">true</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Header</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.125</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c000090e2</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageButton" referent="RBX851B301000EF47D1826A6C9E37B1F9F6">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">false</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.258823544</R>
								<G>0.258823544</G>
								<B>0.258823544</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=6031094678</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">-1</int>
							<bool name="Modal">false</bool>
							<string name="Name">CloseBtn</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">3</token>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0.600000024</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00008b02</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">-1</int>
						</Properties>
						<Item class="UIAspectRatioConstraint" referent="RBX3E088956FE9E4364968A44CD23376215">
							<Properties>
								<float name="AspectRatio">1</float>
								<token name="AspectType">1</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<token name="DominantAxis">1</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UIAspectRatioConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00008c48</UniqueId>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXD9E160BF5D38466BB070F0E6592C54EB">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0.800000012</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Tint</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00009129</UniqueId>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX91FBA6596BA44015B410BA3496F012B7">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.266666681</R>
								<G>0.266666681</G>
								<B>0.266666681</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/Zekton.json</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Title</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<string name="OpenTypeFeatures"></string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.829999983</XS>
								<XO>0</XO>
								<YS>0.699999988</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">Example Header</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">8</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00009418</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UITextSizeConstraint" referent="RBX6F998248F913441EB4A7657B6EB8A8AD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<int name="MaxTextSize">28</int>
								<int name="MinTextSize">18</int>
								<string name="Name">UITextSizeConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00009459</UniqueId>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX1C1CD09F571B4E0797E7946830B02486">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0.0199999996</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0.0199999996</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>0</O>
								</UDim>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c0000949a</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="UIPadding" referent="RBX0E3C6E7353C0427E92974968CAE7BF39">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0.075000003</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0.0250000004</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>0</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c000091ea</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LocalizationService" referent="RBXBBAE1DE690684C54A104D7C3DBAF254C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000332</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX003FF3C6BC134CC08818E350F218C5C4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000335</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX3D6CD7ACDEB94F6D9E0D5007557AF879">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000337</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBXD077275D07C343F3872A52D86CF0A02D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000338</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX3E0D51F3BD14462BAE445B0D2FE07EF4">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000033c</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBX0521AACA1DF943EB81DB25AEB036C3B3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7889031309ed50d5060a27f000006483</UniqueId>
				<string name="Value">{27A6A38B-CEC2-4A1A-BDAD-1BF7A8289705}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX28D08A53147A4B7E98D28D79AD598679">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000033d</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX673F0AB7CF054C80AE7DA103AA503B59">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000033e</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXC718B37BFFB2473F9E604DE3BA197992">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000033f</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX9B67858B497E49EC8F2B8ED460DEC651">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000034c</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX949B2F2828E94CDBB4C403110B10F26A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ControllerModels">1</token>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="FadeOutViewOnCollision">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LaserPointer">1</token>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000343</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXEF49FA8FBCE245B0998CFAF45AA5420B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000344</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXFD7BAFEAC7C946DD94151C2CF8EDE304">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000345</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX55697FC3DFBF4262BEC0141ADF95DAC3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000346</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX0E713731C4094D84853DC4C23E533A15">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000347</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBXFEF45140F29F458B8610E4E17C155A7D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LuaWebService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000355</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBXD4C33D366BEB48C1B9E12CE32AE290C1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000357</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX31B208068E124999969DF593E47CB358">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000034f</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000034d</UniqueId>
		</Properties>
		<Item class="Script" referent="RBX54D57DE6685F419499A0E0F70AEA325E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">UIPresetsPlugin</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{8FF1353B-8CF0-49D8-8F25-00AD816DB0EE}</string>
				<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = require(script.include.RuntimeLib)
local UIPresetsUIHandler = TS.import(script, script, "userInterface", "UIPresetsUIHandler").UIPresetsUIHandler
local toolbar = plugin:CreateToolbar("dev-syn Plugins")
local button = toolbar:CreateButton("UIPresets", "This plugin allows you to interface with UIPresets within Studio using components & presets within Studio.", "")
local WIDGET_INFO = DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Float, true, false, 250, 800, 100, 250)
local DOCK_WIDGET = plugin:CreateDockWidgetPluginGui("dev-syn_UIPresetsPlugin", WIDGET_INFO)
DOCK_WIDGET.Name = "dev-syn.plugins.UIPresets"
DOCK_WIDGET.Title = "UIPresets Plugin"
UIPresetsUIHandler:Init(DOCK_WIDGET)
button.Click:Connect(function()
	DOCK_WIDGET.Enabled = not DOCK_WIDGET.Enabled
	return DOCK_WIDGET.Enabled
end)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c7e</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBXA65A9E61BB9C45278949D4703B644289">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">models</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c7f</UniqueId>
				</Properties>
				<Item class="Frame" referent="RBX3EC7D64A6B1946D3BAC219450AAE1AD0">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.180392161</R>
							<G>0.180392161</G>
							<B>0.180392161</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">UIPresetsBG</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c80</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX58752D6C9B454918BFC12E778B1BBCD7">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.180392161</R>
								<G>0.180392161</G>
								<B>0.180392161</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Content</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.75</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c81</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX4268C44D2A0842FDB60F0CAD5F3E51C3">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.180392161</R>
									<G>0.180392161</G>
									<B>0.180392161</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">NavItem-Main</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c82</UniqueId>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBXFC1C8D647305468A9C97FB0446879F10">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.152941182</R>
										<G>0.152941182</G>
										<B>0.152941182</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Content</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.899999976</XS>
										<XO>0</XO>
										<YS>0.899999976</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c83</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX045E8B6CA1D54C77ACEABFE8079A174E">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.211764723</R>
								<G>0.211764723</G>
								<B>0.211764723</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/DenkOne.json</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Title</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<string name="OpenTypeFeatures"></string>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.0199999996</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.699999988</XS>
								<XO>0</XO>
								<YS>0.0649999976</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">UIPresets</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c8a</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UICorner" referent="RBXD151397D84F64D6DA8A2AAB863B280D1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<UDim name="CornerRadius">
									<S>0.400000006</S>
									<O>0</O>
								</UDim>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c8b</UniqueId>
							</Properties>
						</Item>
						<Item class="UITextSizeConstraint" referent="RBX72B82BEC14D34DC1B6B0A57C5F69C89E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<int name="MaxTextSize">28</int>
								<int name="MinTextSize">12</int>
								<string name="Name">UITextSizeConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">14c2b1ffe8940d050712d29100008159</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXBE0EB756E7534F07B128187B0D56A868">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.219607845</R>
								<G>0.219607845</G>
								<B>0.219607845</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">NavbarBG</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c8c</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ScrollingFrame" referent="RBX4AA15C6683554EDCBEFBD34082134FC4">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">1</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.129411772</R>
									<G>0.129411772</G>
									<B>0.129411772</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<token name="HorizontalScrollBarInset">1</token>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">Navbar</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0</float>
								<int name="ScrollBarThickness">7</int>
								<token name="ScrollingDirection">1</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.899999976</XS>
									<XO>0</XO>
									<YS>0.800000012</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c8d</UniqueId>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextButton" referent="RBXB923274FDC8840E1A62A36D2B2B2A5B7">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.219607845</R>
										<G>0.219607845</G>
										<B>0.219607845</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/PressStart2P.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">ComponentsBtn</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.400000006</XS>
										<XO>0</XO>
										<YS>0.699999988</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Components</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c8f</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UITextSizeConstraint" referent="RBX6F641A6278404CACA168C345B0905C6A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<int name="MaxTextSize">20</int>
										<int name="MinTextSize">14</int>
										<string name="Name">UITextSizeConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c90</UniqueId>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBX8095C4A8D3874B25ACC7156E53A6F7E0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIPadding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>0</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d2910000815c</UniqueId>
									</Properties>
								</Item>
								<Item class="UIAspectRatioConstraint" referent="RBXFA690DE893E54A34A1558B321F004D08">
									<Properties>
										<float name="AspectRatio">2.5</float>
										<token name="AspectType">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="DominantAxis">1</token>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIAspectRatioConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d2910000815d</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX51C79FCAA9EF43E0932E6DE07ACE4F25">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.219607845</R>
										<G>0.219607845</G>
										<B>0.219607845</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/PressStart2P.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">PresetsBtn</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.400000006</XS>
										<XO>0</XO>
										<YS>0.699999988</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Presets</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c91</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UITextSizeConstraint" referent="RBXEF93D2144E544E8F904DA39E692AA1F3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<int name="MaxTextSize">20</int>
										<int name="MinTextSize">14</int>
										<string name="Name">UITextSizeConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c92</UniqueId>
									</Properties>
								</Item>
								<Item class="UIAspectRatioConstraint" referent="RBX56CBCBA537CC493CAE6F02B0D90630C4">
									<Properties>
										<float name="AspectRatio">2.5</float>
										<token name="AspectType">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="DominantAxis">1</token>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIAspectRatioConstraint</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d2910000815a</UniqueId>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBXDCB20623D8654591A6A35C71086F8AA2">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">UIPadding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0.0500000007</S>
											<O>0</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>0</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d2910000815b</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBXF592A22B53844AFD9761A29028141CF0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<UniqueId name="HistoryId">4665e33cded9312a070d123c00007c8e</UniqueId>
									<token name="HorizontalAlignment">0</token>
									<token name="HorizontalFlex">4</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0.100000001</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c000087b0</UniqueId>
									<token name="VerticalAlignment">0</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBX4B149C1F9758495E9A88369732E8A2AA">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">true</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.180392161</R>
								<G>0.180392161</G>
								<B>0.180392161</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=6031280882</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<bool name="Modal">false</bool>
							<string name="Name">SettingsBtn</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.959999979</XS>
								<XO>0</XO>
								<YS>0.0149999997</YS>
								<YO>0</YO>
							</UDim2>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c93</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIAspectRatioConstraint" referent="RBX0442E26AD5414426ADCD163E0D0BCA98">
							<Properties>
								<float name="AspectRatio">1</float>
								<token name="AspectType">1</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<token name="DominantAxis">1</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UIAspectRatioConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">14c2b1ffe8940d050712d29100008158</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX6F89CEF307B04E3BB120728ED06BE672">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">types</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c94</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX342A1138AE9B47E4957A68736F104C92">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">t</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c95</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBXF3A96840D6B44D6C91EC2FFCAEEECEB8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c96</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX8092AF2D23AD40C789EEC278B32F89A9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">instances</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c97</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX6E74CF7C23594C389C8E8180BFB18AB0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">NavItems</string>
									<string name="ScriptGuid">{5751A7A9-8C50-4FB4-921B-B8267C840B67}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local t = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "include", "node_modules", "@rbxts", "t", "lib", "ts").t
local INavItemMain = t.intersection(t.instanceIsA("Frame"), t.children({
	Content = t.instanceIsA("Frame"),
}))
local INavItemPresets = t.intersection(t.instanceIsA("Frame"), t.children({
	CloseBtn = t.instanceIsA("ImageButton"),
	Content = t.instanceIsA("Frame"),
}))
local INavItemComponents = t.intersection(t.instanceIsA("Frame"), t.children({
	CloseBtn = t.instanceIsA("ImageButton"),
	Content = t.instanceIsA("Frame"),
}))
local INavItems = t.intersection(t.instanceIsA("Frame"), t.children({
	["NavItem-Main"] = INavItemMain,
	["NavItem-Presets"] = INavItemPresets,
	["NavItem-Components"] = INavItemComponents,
}))
return INavItems
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c98</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB41325630D3E4FD8BF33CE7C9464D5D3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">userInterface</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c99</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX37792B4813ED444C801D4BCD0DEEB60C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UIPresetsUIHandler</string>
						<string name="ScriptGuid">{70759E1F-E076-4CCD-BE4B-0DB97916751C}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = require(script.Parent.Parent.include.RuntimeLib)
local t = TS.import(script, script.Parent.Parent, "include", "node_modules", "@rbxts", "t", "lib", "ts").t
local INavItems = TS.import(script, script.Parent.Parent, "types", "t", "UI", "instances", "NavItems")
local INavbarBG = t.intersection(t.instanceIsA("Frame"), t.children({
	Navbar = t.intersection(t.instanceIsA("ScrollingFrame"), t.children({
		ComponentsBtn = t.instanceIsA("TextButton"),
		PresetsBtn = t.instanceIsA("TextButton"),
		UIListLayout = t.instanceIsA("UIListLayout"),
	})),
}))
local IUIPresetsBG = t.intersection(t.instanceIsA("Frame"), t.children({
	SettingsBtn = t.instanceIsA("ImageButton"),
	Content = INavItems,
	Title = t.instanceIsA("TextLabel"),
	NavbarBG = INavbarBG,
}))
local UIPresetsUIHandler
do
	UIPresetsUIHandler = setmetatable({}, {
		__tostring = function()
			return "UIPresetsUIHandler"
		end,
	})
	UIPresetsUIHandler.__index = UIPresetsUIHandler
	function UIPresetsUIHandler.new(...)
		local self = setmetatable({}, UIPresetsUIHandler)
		return self:constructor(...) or self
	end
	function UIPresetsUIHandler:constructor()
	end
	function UIPresetsUIHandler:Init(dockWidget)
		self._dockWidget = dockWidget
		self.UIPresetsBG.Parent = dockWidget
	end
	UIPresetsUIHandler.UIPresetsBG = game:GetService("ServerScriptService").UIPresetsPlugin.models.UIPresetsBG:Clone()
end
return {
	UIPresetsUIHandler = UIPresetsUIHandler,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c9a</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXFC376A2EEC9344FA87D0A33407E123C1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">utils</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c9b</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX58510027BBB3496F980C27F64BE48890">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c9c</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX096A73D2A0DD4F288F0E9E2EC06F4908">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">main</string>
							<string name="ScriptGuid">{1570E332-7EE3-4000-B8A1-5A809D6BAD41}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
return nil
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c9d</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXE6988390B0474F0B9FB40C8818F792F9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">include</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c9e</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX301F169941514702B0F455B4E074A0C6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Promise</string>
						<string name="ScriptGuid">{343DC2F3-1079-481F-874D-B864B2F7DE18}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Return a Promise from the success or failure handler and it will be chained onto.

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::


	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.

	Returns a new promise chained from this promise.

	:::caution
	If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.

	:::caution
	`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href="/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence">this example</a>). You should use `andThen` instead if you only care about the Resolved case.
	:::

	:::warning
	Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.
	:::

	Returns a new promise chained from this promise.

	@param doneHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:done(doneHandler)
	assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, "Promise:done"))
	return self:_finally(debug.traceback(nil, 2), doneHandler, true)
end

--[=[
	Same as `andThenCall`, except for `done`.

	Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[=[
	Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:doneReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:done(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00007c9f</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9D28FD576F5341688EE165B455B61986">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RuntimeLib</string>
						<string name="ScriptGuid">{D557FBC9-1086-49E3-A45A-8782FC146CED}</string>
						<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "   " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca0</UniqueId>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXDF49F761FDC747A5858E7858E1E835FC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">node_modules</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca1</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBX6A2389ED41644AFEAA2DB1BFC89CCD1B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">@rbxts</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca2</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX24625A35A71A4931B5AAC0E81C04753E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">beacon</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca3</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXFE9418125E58454A9F7C2321BD5D0A44">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">out</string>
									<string name="ScriptGuid">{BD5FC2BE-D8B9-49F5-9EC0-F16804F54F26}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
--[[
	*
	* Represents a connection to a signal.
]]
local Connection
do
	Connection = setmetatable({}, {
		__tostring = function()
			return "Connection"
		end,
	})
	Connection.__index = Connection
	function Connection.new(...)
		local self = setmetatable({}, Connection)
		return self:constructor(...) or self
	end
	function Connection:constructor(signal, fn)
		self.signal = signal
		self.Connected = true
		self._fn = fn
	end
	function Connection:Disconnect()
		if not self.Connected then
			return nil
		end
		self.Connected = false
		if self.signal._handlerListHead == self then
			self.signal._handlerListHead = self._next
		else
			local prev = self.signal._handlerListHead
			while prev and prev._next ~= self do
				prev = prev._next
			end
			if prev then
				prev._next = self._next
			end
		end
	end
	function Connection:Destroy()
		self:Disconnect()
	end
end
--[[
	*
	* Signals allow events to be dispatched to any number of listeners.
]]
local Signal
do
	Signal = setmetatable({}, {
		__tostring = function()
			return "Signal"
		end,
	})
	Signal.__index = Signal
	function Signal.new(...)
		local self = setmetatable({}, Signal)
		return self:constructor(...) or self
	end
	function Signal:constructor()
		self.waitingThreads = {}
		self._handlerListHead = nil
	end
	function Signal:Connect(callback)
		local connection = Connection.new(self, callback)
		if self._handlerListHead ~= nil then
			connection._next = self._handlerListHead
		end
		self._handlerListHead = connection
		return connection
	end
	function Signal:Once(callback)
		local done = false
		local c
		c = self:Connect(function(...)
			local args = { ... }
			if done then
				return nil
			end
			done = true
			c:Disconnect()
			callback(unpack(args))
		end)
		return c
	end
	function Signal:Fire(...)
		local args = { ... }
		local item = self._handlerListHead
		while item do
			if item.Connected then
				task.spawn(item._fn, unpack(args))
			end
			item = item._next
		end
	end
	function Signal:FireDeferred(...)
		local args = { ... }
		local item = self._handlerListHead
		while item do
			if item.Connected then
				task.defer(item._fn, unpack(args))
			end
			item = item._next
		end
	end
	function Signal:Wait()
		local running = coroutine.running()
		self.waitingThreads[running] = true
		self:Once(function(...)
			local args = { ... }
			self.waitingThreads[running] = nil
			task.spawn(running, unpack(args))
		end)
		return coroutine.yield()
	end
	function Signal:DisconnectAll()
		local item = self._handlerListHead
		while item do
			item.Connected = false
			item = item._next
		end
		self._handlerListHead = nil
		local _waitingThreads = self.waitingThreads
		local _arg0 = function(thread)
			return task.cancel(thread)
		end
		for _v in _waitingThreads do
			_arg0(_v, _v, _waitingThreads)
		end
		table.clear(self.waitingThreads)
	end
	function Signal:Destroy()
		self:DisconnectAll()
	end
end
return {
	Connection = Connection,
	Signal = Signal,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca4</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX80750BFB05B04332A83EC6F35EB795E8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">compiler-types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca5</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBXF87784E0A5F74A908848E8B4509357FC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">types</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca6</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX0F29074C821F4D4CBAE2B814530D6858">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">services</string>
								<string name="ScriptGuid">{B5983921-F8CE-4252-BAD4-8A859FDAE2F6}</string>
								<ProtectedString name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca7</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXD940BDF5E6B840D18F11D1C5E3BAFE45">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">t</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca8</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBXAD52FF513C834DA49C743CA3672AE8EF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">lib</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007ca9</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX591473405DC64AC58E816528A47725C5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ts</string>
										<string name="ScriptGuid">{C4A10DEE-19F3-4C64-82C2-31475AC86F5C}</string>
										<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007caa</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXE3CF724FC7C049DF93125D4C9904B078">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cab</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBXFDE96292E5BA48FDB48C59265C214AE4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">include</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cac</UniqueId>
								</Properties>
								<Item class="Folder" referent="RBX1DA445F298154EC79CD51225CB3EB3CE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">generated</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cad</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX75F75369BE944674A0577AA1D99AB02A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">uipresets</string>
								<string name="ScriptGuid">{95BD731F-19DE-4AC3-BEC3-6F47654844FD}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local UIPresetsConfig = TS.import(script, script, "UIPresetsConfig").UIPresetsConfig
local ContextMenu = TS.import(script, script, "components", "ContextMenu").ContextMenu
local Navbar = TS.import(script, script, "components", "Navbar")
local SelectableGroup = TS.import(script, script, "components", "SelectableGroup").SelectableGroup
local ToolTip = TS.import(script, script, "components", "ToolTip").ToolTip
local _BoundCheck = TS.import(script, script, "components", "BoundCheck")
local BoundCheck = _BoundCheck.BoundCheck
local BoundsLayout = _BoundCheck.BoundsLayout
return {
	UIPresetsConfig = UIPresetsConfig,
	ContextMenu = ContextMenu,
	Navbar = Navbar,
	SelectableGroup = SelectableGroup,
	ToolTip = ToolTip,
	BoundCheck = BoundCheck,
	BoundsLayout = BoundsLayout,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cae</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX0305752E32C14CF5977004D10F791B0A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">UIPresetsConfig</string>
									<string name="ScriptGuid">{6BFA1157-2568-47FB-9DD0-5B2122B5A037}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "beacon").out).Signal
local ComponentRecord = {
	ContextMenu = "ContextMenu",
	Navbar = "Navbar",
	SelectableGroup = "SelectableGroup",
	ToolTip = "ToolTip",
}
--* This is a configuration module for UIPresets that will change behaviour across components. 
local UIPresetsConfig
do
	UIPresetsConfig = setmetatable({}, {
		__tostring = function()
			return "UIPresetsConfig"
		end,
	})
	UIPresetsConfig.__index = UIPresetsConfig
	function UIPresetsConfig.new(...)
		local self = setmetatable({}, UIPresetsConfig)
		return self:constructor(...) or self
	end
	function UIPresetsConfig:constructor()
	end
	function UIPresetsConfig:FetchHighestDisplayOrder()
		local excludedOrders = self._excludedDisplayOrders
		local _exp = self._playerGui:GetChildren()
		--  ReadonlyArray.filter 
		local _newValue = {}
		local _callback = function(child)
			local _condition = child:IsA("ScreenGui")
			if _condition then
				local _child = child
				_condition = not (excludedOrders[_child] ~= nil)
			end
			return _condition
		end
		local _length = 0
		for _k, _v in _exp do
			if _callback(_v, _k - 1, _exp) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		--  ReadonlyArray.filter 
		local children = _newValue
		if #children == 0 then
			return 0
		end
		table.sort(children, function(a, b)
			return a.DisplayOrder > b.DisplayOrder
		end)
		return children[1].DisplayOrder
	end
	function UIPresetsConfig:ExcludeDisplay(ui)
		self:excludeDisplay(ui)
		-- Update the highest display order when the display order is changed
		self:updateDisplayOrder()
	end
	function UIPresetsConfig:ExcludeDisplays(uis)
		for _, ui in uis do
			self:excludeDisplay(ui, true)
		end
		-- Update the highest display order when the display order is changed
		self:updateDisplayOrder()
	end
	function UIPresetsConfig:updateDisplayOrder()
		local newOrder = self:FetchHighestDisplayOrder()
		self.HighestDisplayOrder = newOrder
		self.OnDisplayOrderChanged:Fire(newOrder)
	end
	function UIPresetsConfig:excludeDisplay(ui, deferOrderChanged)
		if deferOrderChanged == nil then
			deferOrderChanged = false
		end
		local uiConnections = {}
		ui.Destroying:Once(function()
			return self:deleteDisplay(ui)
		end)
		if deferOrderChanged then
			task.defer(function(ui, uiConnections)
				local _uiConnections = uiConnections
				local _arg0 = ui:GetPropertyChangedSignal("DisplayOrder"):Connect(function()
					return self:updateDisplayOrder()
				end)
				table.insert(_uiConnections, _arg0)
				return #_uiConnections
			end, ui, uiConnections)
		else
			local _arg0 = ui:GetPropertyChangedSignal("DisplayOrder"):Connect(function()
				return self:updateDisplayOrder()
			end)
			table.insert(uiConnections, _arg0)
		end
		local __excludedConnections = self._excludedConnections
		local _ui = ui
		__excludedConnections[_ui] = uiConnections
	end
	function UIPresetsConfig:deleteDisplay(ui)
		local __excludedConnections = self._excludedConnections
		local _ui = ui
		local uiConnections = __excludedConnections[_ui]
		if uiConnections then
			--  ReadonlyArray.forEach 
			local _callback = function(conn)
				return conn:Disconnect()
			end
			for _k, _v in uiConnections do
				_callback(_v, _k - 1, uiConnections)
			end
			--  ReadonlyArray.forEach 
			local __excludedConnections_1 = self._excludedConnections
			local _ui_1 = ui
			__excludedConnections_1[_ui_1] = nil
		end
		local __excludedDisplayOrders = self._excludedDisplayOrders
		local _ui_1 = ui
		__excludedDisplayOrders[_ui_1] = nil
	end
	UIPresetsConfig.ParallelEnabled = false
	UIPresetsConfig.OnDisplayOrderChanged = Signal.new()
	UIPresetsConfig._excludedDisplayOrders = {}
	UIPresetsConfig._excludedConnections = {}
	UIPresetsConfig._playerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
	do
		UIPresetsConfig._displayOrderConn = UIPresetsConfig._playerGui.ChildAdded:Connect(function()
			local newOrder = UIPresetsConfig:FetchHighestDisplayOrder()
			UIPresetsConfig.HighestDisplayOrder = newOrder
			UIPresetsConfig.OnDisplayOrderChanged:Fire(newOrder)
		end)
		UIPresetsConfig.HighestDisplayOrder = UIPresetsConfig:FetchHighestDisplayOrder()
	end
end
return {
	ComponentRecord = ComponentRecord,
	UIPresetsConfig = UIPresetsConfig,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007caf</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX8688D3013B214860B41D49BE5A743566">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">components</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb0</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX620AC17728EA4C6D9747B882C732F70C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">BoundCheck</string>
										<string name="ScriptGuid">{F1FE56B1-5F26-4038-B2CC-57D3A1999512}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "beacon").out).Signal
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local UserInputService = _services.UserInputService
local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
--* A table of configurable options that change the default behavior of {@link BoundCheck}. 
--* A bound coordinate contains a X and Y absolute position. 
local function newBoundCoord(x, y)
	if x == nil then
		x = 0
	end
	if y == nil then
		y = 0
	end
	return {
		X = x,
		Y = y,
	}
end
--[[
	*
	 * This stores the bounds layout of a {@link BoundCheck} object.
	 
]]
local BoundsLayout
do
	BoundsLayout = setmetatable({}, {
		__tostring = function()
			return "BoundsLayout"
		end,
	})
	BoundsLayout.__index = BoundsLayout
	function BoundsLayout.new(...)
		local self = setmetatable({}, BoundsLayout)
		return self:constructor(...) or self
	end
	function BoundsLayout:constructor(c1, c2, c3, c4, size)
		if c1 == nil then
			c1 = {
				X = 0,
				Y = 0,
			}
		end
		if c2 == nil then
			c2 = {
				X = 0,
				Y = 0,
			}
		end
		if c3 == nil then
			c3 = {
				X = 0,
				Y = 0,
			}
		end
		if c4 == nil then
			c4 = {
				X = 0,
				Y = 0,
			}
		end
		if size == nil then
			size = {
				X = 0,
				Y = 0,
			}
		end
		self.C1 = c1
		self.C2 = c2
		self.C3 = c3
		self.C4 = c4
		self.Size = size
	end
	BoundsLayout.__tostring = function(lay)
		return `\{\
            C1(X: {lay.C1.X}, Y: {lay.C1.Y}),\
            C2(X: {lay.C2.X}, Y: {lay.C2.Y}),\
            C3(X: {lay.C3.X}, Y: {lay.C3.Y}),\
            C4(X: {lay.C4.X}, Y: {lay.C4.Y}),\
\
            Size(X: {lay.Size.X}, Y: {lay.Size.Y})\
        \}`
	end
end
--[[
	*
	 * This is a UIPresets component that checks if the mouse is within a UI element bounds.
	 
]]
local BoundCheck
do
	BoundCheck = setmetatable({}, {
		__tostring = function()
			return "BoundCheck"
		end,
	})
	BoundCheck.__index = BoundCheck
	function BoundCheck.new(...)
		local self = setmetatable({}, BoundCheck)
		return self:constructor(...) or self
	end
	function BoundCheck:constructor(targetElement, activeOnStart)
		if activeOnStart == nil then
			activeOnStart = true
		end
		self.Options = {
			TopMostOnly = false,
			IgnoreGuiInset = false,
			ConsiderVisibility = true,
		}
		self.BoundEnter = Signal.new()
		self.BoundExit = Signal.new()
		self._withinBounds = false
		self.TargetElement = targetElement
		self.Active = activeOnStart
		self.TargetElement.Destroying:Once(function()
			return self:Destroy()
		end)
		local __boundChecks = BoundCheck._boundChecks
		local _self = self
		__boundChecks[_self] = true
	end
	function BoundCheck:InBounds()
		return self._withinBounds
	end
	function BoundCheck:Query()
		if not self.TargetElement then
			return false
		end
		if self.Options.ConsiderVisibility and not self.TargetElement.Visible then
			print("Not visible")
			return false
		end
		if not self._ancestorSG then
			self._ancestorSG = self.TargetElement:FindFirstAncestorWhichIsA("ScreenGui")
		end
		local mousePos = UserInputService:GetMouseLocation()
		if not mousePos then
			return false
		end
		if self.Options.TopMostOnly then
			local uis = PlayerGui:GetGuiObjectsAtPosition(mousePos.X, mousePos.Y)
			if #uis == 0 then
				return false
			end
			if uis[1] ~= self.TargetElement then
				return false
			end
		end
		local tElem = self.TargetElement
		local absXSize = tElem.AbsoluteSize.X
		local absYSize = tElem.AbsoluteSize.Y
		-- The left absolute position of the bound box
		local leftAbsX = tElem.AbsolutePosition.X
		-- The right absolute position of the bound box
		local rightAbsX = leftAbsX + absXSize
		-- The top absolute position of the bound box
		local topAbsY = if not self.Options.IgnoreGuiInset and self._ancestorSG then tElem.AbsolutePosition.Y - self._ancestorSG.AbsolutePosition.Y else tElem.AbsolutePosition.Y
		-- The bottom absolute position of the bound box
		local bottomAbsY = topAbsY + absYSize
		local withinX = mousePos.X >= leftAbsX and mousePos.X <= rightAbsX
		local withinY = mousePos.Y >= topAbsY and mousePos.Y <= bottomAbsY
		local withinBounds = withinX and withinY
		self.Bounds = BoundsLayout.new(newBoundCoord(leftAbsX, topAbsY), newBoundCoord(rightAbsX, topAbsY), newBoundCoord(leftAbsX, bottomAbsY), newBoundCoord(rightAbsX, bottomAbsY), newBoundCoord(absXSize, absYSize))
		-- If not within bounds mark as leaving bounds
		if not withinBounds then
			if self._withinBounds then
				self._withinBounds = false
				self.BoundExit:Fire()
			end
			return false
		else
			-- Mark if not already marked as in bounds
			if not self._withinBounds then
				self._withinBounds = true
				self.BoundEnter:Fire()
			end
			return true
		end
	end
	function BoundCheck:Destroy()
		self.Active = false
		local __boundChecks = BoundCheck._boundChecks
		local _self = self
		__boundChecks[_self] = nil
		-- Clean up signal events
		if self.BoundEnter then
			self.BoundEnter:Destroy()
			self.BoundEnter = nil
		end
		if self.BoundExit then
			self.BoundExit:Destroy()
			self.BoundExit = nil
		end
		self.TargetElement = nil
	end
	BoundCheck._boundChecks = {}
	do
		RunService:BindToRenderStep("UIPresets_BoundCheck", Enum.RenderPriority.Input.Value + 5, function()
			for boundCheck, _ in pairs(BoundCheck._boundChecks) do
				if not boundCheck.Active then
					continue
				end
				boundCheck:Query()
			end
		end)
	end
end
return {
	BoundCheck = BoundCheck,
	BoundsLayout = BoundsLayout,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb1</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX8493F6D426BE4D3AAE2D68EC01AF73E6">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ContextMenu</string>
										<string name="ScriptGuid">{60C34C0B-CC2F-4BB3-BD80-12C7A4AC7AEF}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local UIPresetsConfig = TS.import(script, script.Parent.Parent, "UIPresetsConfig").UIPresetsConfig
local RunService = game:GetService("RunService")
--[[
	*
	 * ContextItem is the makeup of each item available in the ContextMenu.
	 
]]
local ContextItem
do
	ContextItem = setmetatable({}, {
		__tostring = function()
			return "ContextItem"
		end,
	})
	ContextItem.__index = ContextItem
	function ContextItem.new(...)
		local self = setmetatable({}, ContextItem)
		return self:constructor(...) or self
	end
	function ContextItem:constructor(name, action)
		self.btn = Instance.new("TextButton")
		self.isActive = true
		self.name = name
		self._action = action
		self.btn.Name = `ContextItem-{self.name}`
		self.btn.BackgroundColor3 = Color3.fromRGB(64, 64, 64)
		self.btn.TextColor3 = Color3.fromRGB(255, 255, 255)
		self.btn.AutoButtonColor = true
		self.btn.Text = self.name
		self.btn.BorderMode = Enum.BorderMode.Middle
		self._connection = self.btn.MouseButton1Click:Connect(function()
			return self._action()
		end)
		self.btn.Visible = true
	end
	function ContextItem:SetActive(active)
		if active then
			-- If there is already a connection then we are already active
			if self.isActive or self._connection then
				return nil
			end
			if not self._connection then
				self.btn.MouseButton1Click:Connect(function()
					return self._action()
				end)
			end
			self.btn.Visible = true
			self.isActive = true
		else
			if not self.isActive then
				return nil
			end
			if self._connection then
				self._connection:Disconnect()
				self._connection = nil
			end
			self.btn.Visible = false
			self.isActive = false
		end
	end
	function ContextItem:Destroy()
		self.btn:Destroy()
		self._connection = nil
	end
end
--[[
	*
	 * @enum {number}
	 * The TextSizingMode enum contains modes that affect the text sizing of the @see {@link ContextItem} title text.
	 
]]
local TextSizingMode
do
	local _inverse = {}
	TextSizingMode = setmetatable({}, {
		__index = _inverse,
	})
	TextSizingMode.MinimumCommon = 0
	_inverse[0] = "MinimumCommon"
	TextSizingMode.Scaled = 1
	_inverse[1] = "Scaled"
end
--[[
	*
	 * @interface
	 * These are the options that can be passed to ContextMenu to change default ContextMenu behavior.
	 
]]
local ContextMenu
do
	ContextMenu = setmetatable({}, {
		__tostring = function()
			return "ContextMenu"
		end,
	})
	ContextMenu.__index = ContextMenu
	function ContextMenu.new(...)
		local self = setmetatable({}, ContextMenu)
		return self:constructor(...) or self
	end
	function ContextMenu:constructor(triggerElement, contexts)
		self.menuBG = Instance.new("Frame")
		self.itemSize = Vector2.new(1, 1)
		self.textSizeScaler = 1
		self.options = {
			textSizingMode = TextSizingMode.MinimumCommon,
		}
		self._contexts = {}
		self._connections = {}
		if not (t.instanceIsA("TextButton") or t.instanceIsA("ImageButton")) then
			error("TriggerElement must be an instance of TextButton | ImageButton.")
		end
		self.menuBG.Name = `ContextMenu-{triggerElement.Name}`
		self.menuBG.BackgroundColor3 = Color3.fromRGB(64, 64, 64)
		self.menuBG.Visible = true
		-- When the trigger element is right clicked draw and display the context menu
		local __connections = self._connections
		local _arg0 = triggerElement.MouseButton2Click:Connect(function()
			if ContextMenu.onlySingleContext and ContextMenu._previousMenu and ContextMenu._previousMenu ~= self then
				ContextMenu._previousMenu.menuBG.Parent = nil
			end
			if not self.menuBG.Parent then
				self:Draw()
				self.menuBG.Parent = ContextMenu.contextMenuSG
			else
				self.menuBG.Parent = nil
				if ContextMenu._previousMenu == self then
					ContextMenu._previousMenu = nil
				end
			end
		end)
		table.insert(__connections, _arg0)
		-- When the trigger element's position is changed, redraw the context menu.
		local __connections_1 = self._connections
		local _arg0_1 = triggerElement:GetPropertyChangedSignal("Position"):Connect(function()
			return self:Draw()
		end)
		table.insert(__connections_1, _arg0_1)
		triggerElement.Destroying:Connect(function()
			return self:Destroy()
		end)
		self.triggerElement = triggerElement
		if not contexts then
			return nil
		end
		--  ReadonlyArray.forEach 
		local _callback = function(item)
			local __contexts = self._contexts
			local _item = item
			table.insert(__contexts, _item)
			return #__contexts
		end
		for _k, _v in contexts do
			_callback(_v, _k - 1, contexts)
		end
		--  ReadonlyArray.forEach 
	end
	function ContextMenu:Init()
		-- Updates the text size of these context items that are TextButton elements
		self:updateTextSize()
	end
	function ContextMenu:Draw()
		local _value = self._itemTextSize
		if not (_value ~= 0 and _value == _value and _value) then
			self:updateTextSize()
		end
		-- Get the updated screen size
		self.viewSize = ContextMenu.contextMenuSG.AbsoluteSize
		local activeContexts = self:GetActiveContexts()
		local contextSize = #activeContexts
		-- If no context; don't draw anything
		if contextSize == 0 then
			return nil
		end
		-- If minItemSizeX was set to zero, assign it 1
		if self.itemSize.X == 0 then
			local _itemSize = self.itemSize
			local _vector2 = Vector2.new(1, self.itemSize.Y)
			self.itemSize = _itemSize + _vector2
		end
		-- If minItemSizeY was set to zero, assign it 1
		if self.itemSize.Y == 0 then
			local _itemSize = self.itemSize
			local _vector2 = Vector2.new(self.itemSize.X, 1)
			self.itemSize = _itemSize + _vector2
		end
		-- The absolute size of the trigger element
		local absSizeY = self.triggerElement.AbsoluteSize.Y
		-- The absolute position of the trigger element
		local absPosY = self.triggerElement.AbsolutePosition.Y
		-- The minimum absolute size of each context item
		local itemAbsSizeY = math.ceil(self.itemSize.Y * absSizeY)
		-- Get the used amount of space on the x axis in pixels of each context item
		local itemAbsSizeX = math.ceil(self.itemSize.X * self.triggerElement.AbsoluteSize.X)
		-- Calculate the absolute position of the element from the top
		local yAnchor = self.triggerElement.AnchorPoint.Y
		-- Calculate the top left absolute y position of the trigger element
		local topAbsPosY = math.ceil(absPosY - absSizeY * yAnchor)
		-- Calculate the left absolute x position of the trigger element
		local leftAbsPosX = self.triggerElement.AbsolutePosition.X - math.ceil(self.triggerElement.AbsoluteSize.X * self.triggerElement.AnchorPoint.X)
		-- #region ROWS_COLUMNS
		-- Is the trigger element positioned over half the y screen
		local isSizeOverHalfY = absPosY > self.viewSize.Y / 2
		local availableYPixels
		if isSizeOverHalfY then
			-- Prioritize pushing the context menu upwards before more columns
			availableYPixels = topAbsPosY
		else
			-- Check how much space is available going down
			availableYPixels = self.viewSize.Y - topAbsPosY
		end
		-- Calculate the rows available from the (minimum size / available pixels)
		local rows = math.floor(availableYPixels / itemAbsSizeY)
		-- If there are less rows than context lower rows to contextSize
		if rows > contextSize then
			rows = contextSize
		end
		-- There is always one column
		local columns = 1
		-- If there is more items then rows available then create columns
		if rows > 0 and rows < contextSize then
			columns = math.ceil(contextSize / rows)
		end
		-- Set the size of MenuBG x based on amount of columns and y based on rows
		self.menuBG.Size = UDim2.new(0, columns * itemAbsSizeX, 0, rows * itemAbsSizeY)
		-- Calculate the right absolute position of the trigger element
		local rightAbsPosX = leftAbsPosX + itemAbsSizeX
		local isSizeOverHalfX = leftAbsPosX > self.viewSize.X / 2
		self.menuBG.Position = UDim2.new(0, if isSizeOverHalfX then leftAbsPosX - self.menuBG.AbsoluteSize.X else rightAbsPosX + (self.triggerElement.AbsoluteSize.X - itemAbsSizeX), 0, if isSizeOverHalfY then (topAbsPosY + -(self.menuBG.AbsoluteSize.Y - math.ceil((1 / self.itemSize.Y) * itemAbsSizeY))) else topAbsPosY)
		local itemIndex = 0
		-- Negate the minimum abs size for first element
		local lastPos = UDim2.new(0, 0, 0, -itemAbsSizeY)
		do
			local columnIndex = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					columnIndex += 1
				else
					_shouldIncrement = true
				end
				if not (columnIndex < columns) then
					break
				end
				do
					local rowIndex = 0
					local _shouldIncrement_1 = false
					while true do
						if _shouldIncrement_1 then
							rowIndex += 1
						else
							_shouldIncrement_1 = true
						end
						if not (rowIndex < rows) then
							break
						end
						local item = activeContexts[itemIndex + 1]
						-- If out of items then break
						if not item then
							break
						end
						item.btn.Size = UDim2.new(0, itemAbsSizeX, 0, itemAbsSizeY)
						local _lastPos = lastPos
						local _uDim2 = UDim2.new(0, 0, 0, itemAbsSizeY)
						item.btn.Position = _lastPos + _uDim2
						lastPos = item.btn.Position
						itemIndex += 1
					end
				end
				lastPos = UDim2.new(0, itemAbsSizeX * (columnIndex + 1), 0, -itemAbsSizeY)
			end
		end
		-- #endregion
		-- Parent each context item button to the MenuBG
		--  ReadonlyArray.forEach 
		local _callback = function(c)
			if c.btn:IsA("TextButton") then
				c.btn.TextSize = self._itemTextSize
			end
			c.btn.Parent = self.menuBG
		end
		for _k, _v in activeContexts do
			_callback(_v, _k - 1, activeContexts)
		end
		--  ReadonlyArray.forEach 
		ContextMenu._previousMenu = self
	end
	function ContextMenu:GetCommonTextSize(absX, absY)
		local commonSize = 80
		local tl = ContextMenu.textFitLabel
		tl.TextSize = commonSize
		tl.Size = UDim2.new(0, absX, 0, absY)
		for _, item in self:GetActiveContexts() do
			if not item.btn:IsA("TextButton") then
				continue
			end
			tl.Text = item.name
			while not tl.TextFits do
				if commonSize == 2 then
					break
				end
				commonSize -= 2
				tl.TextSize = commonSize
				RunService.Heartbeat:Wait()
			end
			commonSize = tl.TextSize
		end
		return commonSize - commonSize / 4
	end
	function ContextMenu:GetActiveContexts()
		local _exp = self._contexts
		--  ReadonlyArray.filter 
		local _newValue = {}
		local _callback = function(c)
			return c.isActive
		end
		local _length = 0
		for _k, _v in _exp do
			if _callback(_v, _k - 1, _exp) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		--  ReadonlyArray.filter 
		return _newValue
	end
	function ContextMenu:AddContext(context)
		local __contexts = self._contexts
		local _context = context
		table.insert(__contexts, _context)
		self:updateTextSize()
	end
	function ContextMenu:RemoveContext(context)
		local __contexts = self._contexts
		local _context = context
		local index = (table.find(__contexts, _context) or 0) - 1
		if index ~= -1 then
			table.remove(self._contexts, index + 1)
		end
		self:updateTextSize()
	end
	function ContextMenu:Clear()
		local _exp = self._contexts
		--  ReadonlyArray.forEach 
		local _callback = function(c)
			return c:Destroy()
		end
		for _k, _v in _exp do
			_callback(_v, _k - 1, _exp)
		end
		--  ReadonlyArray.forEach 
		table.clear(self._contexts)
	end
	function ContextMenu:Destroy()
		-- Destroy each ContextItem
		local _exp = self._contexts
		--  ReadonlyArray.forEach 
		local _callback = function(item)
			return item:Destroy()
		end
		for _k, _v in _exp do
			_callback(_v, _k - 1, _exp)
		end
		--  ReadonlyArray.forEach 
		-- Disconnect each connection of this ContextMenu
		local _exp_1 = self._connections
		--  ReadonlyArray.forEach 
		local _callback_1 = function(conn)
			return conn:Disconnect()
		end
		for _k, _v in _exp_1 do
			_callback_1(_v, _k - 1, _exp_1)
		end
		--  ReadonlyArray.forEach 
		self._connections = {}
		self.menuBG.Parent = nil
		self.triggerElement = nil
		if ContextMenu._previousMenu == self then
			ContextMenu._previousMenu = nil
		end
	end
	function ContextMenu:updateTextSize()
		if not self.triggerElement:IsA("TextButton") then
			return nil
		end
		if self.options.textSizingMode == TextSizingMode.MinimumCommon then
			-- The minimum absolute size of each context item on the y axis
			local itemAbsSizeY = math.ceil(self.itemSize.Y * self.triggerElement.AbsoluteSize.Y)
			-- The minimum absolute size of each context item on the x axis
			local itemAbsSizeX = math.ceil(self.itemSize.X * self.triggerElement.AbsoluteSize.X)
			self._itemTextSize = self:GetCommonTextSize(itemAbsSizeX, itemAbsSizeY)
		elseif self.options.textSizingMode == TextSizingMode.Scaled then
			self._itemTextSize = self.textSizeScaler * self.triggerElement.TextSize
		end
	end
	ContextMenu.contextMenuSG = Instance.new("ScreenGui")
	ContextMenu.textFitLabel = Instance.new("TextLabel")
	ContextMenu.onlySingleContext = true
	ContextMenu._previousMenu = nil
	do
		ContextMenu.contextMenuSG.Name = "UIPresets_ContextMenu"
		ContextMenu.contextMenuSG.DisplayOrder = UIPresetsConfig.HighestDisplayOrder + 1
		ContextMenu.contextMenuSG.ResetOnSpawn = false
		ContextMenu.contextMenuSG.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
		ContextMenu.textFitLabel.Position = UDim2.new(2, 0, 2, 0)
		ContextMenu.textFitLabel.Parent = ContextMenu.contextMenuSG
		-- When the HighestDisplayOrder is changed update the ContextMenuSG DisplayOrder
		UIPresetsConfig.OnDisplayOrderChanged:Connect(function(newOrder)
			local _exp = ContextMenu.contextMenuSG
			_exp.DisplayOrder = newOrder + 1
			return _exp.DisplayOrder
		end)
	end
end
return {
	ContextMenu = ContextMenu,
	ContextItem = ContextItem,
	TextSizingMode = TextSizingMode,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb2</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3C286A9429584416BBA5EE441D2015D3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Navbar</string>
										<string name="ScriptGuid">{074F73A8-4017-4D3B-A094-E1D2E8A6402A}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
--[[
	*
	 * This is a UI component that was designed to ease the flow of a navigation UI. Allowing you to assign buttons to a frame and when they are clicked will show that frame and hide the previous.
	 
]]
local Navbar
do
	Navbar = setmetatable({}, {
		__tostring = function()
			return "Navbar"
		end,
	})
	Navbar.__index = Navbar
	function Navbar.new(...)
		local self = setmetatable({}, Navbar)
		return self:constructor(...) or self
	end
	function Navbar:constructor(navBar, navigationableFrames, mainBtn)
		self.NavBarUI = navBar
		self.NavigationableFrames = navigationableFrames
		self.MainBtn = mainBtn
	end
	function Navbar:ShowButtons(uiObjects)
		for _, child in self.NavBarUI:GetChildren() do
			if child:IsA("TextButton") or child:IsA("ImageButton") then
				local uiObject = child
				uiObject.Visible = if uiObject ~= self.MainBtn then table.find(uiObjects, uiObject) ~= nil else true
			end
		end
	end
	function Navbar:HideButtons(uiObjects)
		for _, child in self.NavBarUI:GetChildren() do
			if child:IsA("TextButton") or child:IsA("ImageButton") then
				local uiObject = child
				if table.find(uiObjects, uiObject) ~= nil then
					-- If a MainBtn exist, check if the ui is the main button and prevent visibility change
					if self.MainBtn and uiObject == self.MainBtn then
						continue
					end
					uiObject.Visible = false
				end
			end
		end
	end
	function Navbar:HideAllButtons()
		for _, child in self.NavBarUI:GetChildren() do
			if child:IsA("GuiObject") then
				local uiObject = child
				if self.MainBtn and self.MainBtn == uiObject then
					continue
				end
				uiObject.Visible = false
			end
		end
	end
	function Navbar:AssignFrame(navBtn, frame)
		local _navigationableFrames = self.NavigationableFrames
		local _navBtn = navBtn
		local _frame = frame
		_navigationableFrames[_navBtn] = _frame
		navBtn.MouseButton1Click:Connect(function()
			if self.CurrentFrame and self.CurrentFrame ~= frame then
				self.CurrentFrame.Visible = false
			end
			frame.Visible = true
			self.CurrentFrame = frame
		end)
	end
	function Navbar:ShowFrame(navBtn)
		local _navigationableFrames = self.NavigationableFrames
		local _navBtn = navBtn
		local navFrame = _navigationableFrames[_navBtn]
		if not navFrame then
			return nil
		end
		if self.CurrentFrame then
			self.CurrentFrame.Visible = false
		end
		self.CurrentFrame = navFrame
		navFrame.Visible = true
	end
end
return Navbar
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb3</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9D3FC7566FFD45DD97B18E325C728654">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">SelectableGroup</string>
										<string name="ScriptGuid">{2DB441C6-B7DD-4768-9DA5-B01E11126E22}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "beacon").out).Signal
--* The SelectableGroupConfig is a configurable set of options that changes the default behavior. 
local rand = Random.new()
--[[
	*
	 * This class allows you to group TextButton/ImageButton buttons together and allow single or multiple selections between those buttons.
	 
]]
local SelectableGroup
do
	SelectableGroup = setmetatable({}, {
		__tostring = function()
			return "SelectableGroup"
		end,
	})
	SelectableGroup.__index = SelectableGroup
	function SelectableGroup.new(...)
		local self = setmetatable({}, SelectableGroup)
		return self:constructor(...) or self
	end
	function SelectableGroup:constructor(group)
		self.CurrentSelection = {}
		self.SelectionChanged = Signal.new()
		self.Config = {
			isSingleOnly = false,
			requireSelection = false,
			borderColor = Color3.fromRGB(255, 255, 255),
			borderSize = 2,
		}
		self.selectableConnections = {}
		self.SelectionGroup = {}
		if group then
			--  ReadonlyArray.forEach 
			local _callback = function(btn)
				return self:Add(btn)
			end
			for _k, _v in group do
				_callback(_v, _k - 1, group)
			end
			--  ReadonlyArray.forEach 
		end
	end
	function SelectableGroup:Init()
		if self.DefaultSelection then
			local _selectionGroup = self.SelectionGroup
			local _defaultSelection = self.DefaultSelection
			if not (table.find(_selectionGroup, _defaultSelection) ~= nil) then
				local _selectionGroup_1 = self.SelectionGroup
				local _defaultSelection_1 = self.DefaultSelection
				table.insert(_selectionGroup_1, _defaultSelection_1)
			end
			-- Make the default button selected
			local _currentSelection = self.CurrentSelection
			local _defaultSelection_1 = self.DefaultSelection
			table.insert(_currentSelection, _defaultSelection_1)
			self.DefaultSelection.BorderSizePixel = self.Config.borderSize
		end
	end
	function SelectableGroup:Select(newSelection)
		local config = self.Config
		if newSelection then
			local _selectionGroup = self.SelectionGroup
			local _newSelection = newSelection
			if not (table.find(_selectionGroup, _newSelection) ~= nil) then
				warn(`Could not select new selection since it doesn't exist in the selection group with button name: {newSelection.Name}`)
				return nil
			end
			if self:IsSelected(newSelection) then
				warn("Could not select new selection since it already is selected.")
				return nil
			end
			local prevSelection = self.CurrentSelection[1]
			if config.isSingleOnly and prevSelection then
				prevSelection.BorderSizePixel = 0
				local _exp = self.CurrentSelection
				_exp[#_exp] = nil
			end
			local _currentSelection = self.CurrentSelection
			local _newSelection_1 = newSelection
			table.insert(_currentSelection, _newSelection_1)
			newSelection.BorderSizePixel = self.Config.borderSize
			self.SelectionChanged:Fire(prevSelection, newSelection)
		else
			if not config.isSingleOnly then
				warn("Could not select a non existent selection with multi-selections, use UnselectAll() instead.")
				return nil
			end
			local selectionsSize = #self.CurrentSelection
			if selectionsSize == 0 then
				warn("Could not remove selection from selection group no selection is present.")
				return nil
			end
			if config.requireSelection and selectionsSize == 1 then
				warn("Could not remove selection from selection group; since a selection is required.")
				return nil
			end
			local prevSelection = self.CurrentSelection[1]
			prevSelection.BorderSizePixel = 0
			local _exp = self.CurrentSelection
			_exp[#_exp] = nil
			self.SelectionChanged:Fire(prevSelection, nil)
		end
	end
	function SelectableGroup:Add(button)
		-- Check if this button is already in this SelectableGroup
		local _selectionGroup = self.SelectionGroup
		local _button = button
		if table.find(_selectionGroup, _button) ~= nil then
			return nil
		end
		local _selectionGroup_1 = self.SelectionGroup
		local _button_1 = button
		table.insert(_selectionGroup_1, _button_1)
		button.BorderColor3 = self.Config.borderColor
		local _selectableConnections = self.selectableConnections
		local _button_2 = button
		local selectableConnections = _selectableConnections[_button_2]
		if not selectableConnections then
			selectableConnections = {}
			local _selectableConnections_1 = self.selectableConnections
			local _button_3 = button
			local _selectableConnections_2 = selectableConnections
			_selectableConnections_1[_button_3] = _selectableConnections_2
		end
		-- When the button is destroyed remove any references to that button
		local _selectableConnections_1 = selectableConnections
		local _arg0 = button.Destroying:Connect(function()
			local _currentSelection = self.CurrentSelection
			local _button_3 = button
			local btnSelectionIndex = (table.find(_currentSelection, _button_3) or 0) - 1
			if btnSelectionIndex ~= -1 then
				table.remove(self.CurrentSelection, btnSelectionIndex + 1)
			end
			local _selectionGroup_2 = self.SelectionGroup
			local _button_4 = button
			local btnGroupIndex = (table.find(_selectionGroup_2, _button_4) or 0) - 1
			if btnGroupIndex ~= -1 then
				table.remove(self.SelectionGroup, btnGroupIndex + 1)
			end
		end)
		table.insert(_selectableConnections_1, _arg0)
		local borderSize = self.Config.borderSize
		local _selectableConnections_2 = selectableConnections
		local _arg0_1 = button.MouseButton1Click:Connect(function()
			-- If only one button can be selected at a time
			if self.Config.isSingleOnly then
				-- If this is the only selection that is being toggled; remove this selection
				if self.CurrentSelection[1] == button then
					-- If a selection is required and this is the only selection; return
					if self.Config.requireSelection then
						return nil
					end
					local prevSelection = self.CurrentSelection[1]
					-- Unselect the current button
					prevSelection.BorderSizePixel = 0
					table.remove(self.CurrentSelection, 1)
					self.SelectionChanged:Fire(prevSelection, nil)
				else
					local prevSelection = self.CurrentSelection[1]
					if prevSelection then
						-- Unselect the current button and select this button
						prevSelection.BorderSizePixel = 0
						table.remove(self.CurrentSelection, 1)
					end
					local _currentSelection = self.CurrentSelection
					local _button_3 = button
					table.insert(_currentSelection, _button_3)
					button.BorderSizePixel = borderSize
					self.SelectionChanged:Fire(prevSelection, button)
				end
			else
				-- Check if this btn is already selected
				local _currentSelection = self.CurrentSelection
				local _button_3 = button
				local btnIndex = (table.find(_currentSelection, _button_3) or 0) - 1
				if btnIndex ~= -1 then
					-- If a selection is required and this is the last button selected; return
					if self.Config.requireSelection and #self.CurrentSelection == 1 then
						return nil
					end
					local prevSelection = self.CurrentSelection[1]
					prevSelection.BorderSizePixel = 0
					table.remove(self.CurrentSelection, btnIndex + 1)
					self.SelectionChanged:Fire(prevSelection, nil)
				else
					local _currentSelection_1 = self.CurrentSelection
					local _button_4 = button
					table.insert(_currentSelection_1, _button_4)
					button.BorderSizePixel = borderSize
					self.SelectionChanged:Fire(nil, button)
				end
			end
		end)
		table.insert(_selectableConnections_2, _arg0_1)
	end
	function SelectableGroup:Remove(button, force)
		if force == nil then
			force = false
		end
		local _selectionGroup = self.SelectionGroup
		local _button = button
		local btnGroupIndex = (table.find(_selectionGroup, _button) or 0) - 1
		-- Check if this button is not in this SelectableGroup
		if btnGroupIndex == -1 then
			return nil
		end
		-- Check if this button is selected
		local _currentSelection = self.CurrentSelection
		local _button_1 = button
		local btnSelectionIndex = (table.find(_currentSelection, _button_1) or 0) - 1
		if btnSelectionIndex ~= -1 then
			-- This button is currently selected
			-- If this SelectableGroup requires a selection and there is only one without force specified; return
			if self.Config.requireSelection and #self.CurrentSelection == 1 and not force then
				return nil
			end
			table.remove(self.CurrentSelection, btnSelectionIndex + 1)
		end
		-- Remove connections for this button
		self:removeButtonConnections(button)
		table.remove(self.SelectionGroup, btnGroupIndex + 1)
		button.BorderSizePixel = 0
	end
	function SelectableGroup:SelectAll()
		if #self.SelectionGroup == 0 then
			return nil
		end
		-- Only allow selecting all on multi' selections
		if self.Config.isSingleOnly then
			return nil
		end
		local borderSize = self.Config.borderSize
		for _, btn in self.SelectionGroup do
			local btnIndex = (table.find(self.CurrentSelection, btn) or 0) - 1
			if btnIndex ~= -1 then
				continue
			end
			local _exp = self.CurrentSelection
			table.insert(_exp, btn)
			btn.BorderSizePixel = borderSize
		end
	end
	function SelectableGroup:UnselectAll()
		local groupSize = #self.SelectionGroup
		if groupSize == 0 then
			return nil
		end
		if self.Config.requireSelection then
			local reservedButton = self.DefaultSelection or self.SelectionGroup[rand:NextInteger(1, groupSize) + 1]
			do
				local btnIndex = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						btnIndex += 1
					else
						_shouldIncrement = true
					end
					if not (btnIndex < groupSize) then
						break
					end
					local button = self.SelectionGroup[btnIndex + 1]
					-- If this is the reserved button do not unselect it
					if button == reservedButton then
						continue
					end
					local btnSelectionIndex = (table.find(self.CurrentSelection, button) or 0) - 1
					--  Array.unorderedRemove 
					local _index = btnSelectionIndex + 1
					local _exp = self.CurrentSelection
					local _length = #_exp
					local _value = _exp[_index]
					if _value ~= nil then
						_exp[_index] = _exp[_length]
						_exp[_length] = nil
					end
					--  Array.unorderedRemove 
				end
			end
		else
			do
				local btnIndex = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						btnIndex += 1
					else
						_shouldIncrement = true
					end
					if not (btnIndex < groupSize) then
						break
					end
					local button = self.SelectionGroup[btnIndex + 1]
					local btnSelectionIndex = (table.find(self.CurrentSelection, button) or 0) - 1
					--  Array.unorderedRemove 
					local _index = btnSelectionIndex + 1
					local _exp = self.CurrentSelection
					local _length = #_exp
					local _value = _exp[_index]
					if _value ~= nil then
						_exp[_index] = _exp[_length]
						_exp[_length] = nil
					end
					--  Array.unorderedRemove 
				end
			end
		end
	end
	function SelectableGroup:IsSelected(btn)
		local _currentSelection = self.CurrentSelection
		local _btn = btn
		return table.find(_currentSelection, _btn) ~= nil
	end
	function SelectableGroup:Destroy()
		-- Clear all the button references to each button in this group
		local _exp = self.SelectionGroup
		--  ReadonlyArray.forEach 
		local _callback = function(button)
			return self:removeButtonConnections(button)
		end
		for _k, _v in _exp do
			_callback(_v, _k - 1, _exp)
		end
		--  ReadonlyArray.forEach 
		-- Clear all table references
		table.clear(self.CurrentSelection)
		table.clear(self.SelectionGroup)
	end
	function SelectableGroup:removeButtonConnections(button)
		local _selectableConnections = self.selectableConnections
		local _button = button
		local selectableConnections = _selectableConnections[_button]
		if not selectableConnections then
			return nil
		end
		--  ReadonlyArray.forEach 
		local _callback = function(conn)
			return conn:Disconnect()
		end
		for _k, _v in selectableConnections do
			_callback(_v, _k - 1, selectableConnections)
		end
		--  ReadonlyArray.forEach 
		local _selectableConnections_1 = self.selectableConnections
		local _button_1 = button
		_selectableConnections_1[_button_1] = nil
	end
end
return {
	SelectableGroup = SelectableGroup,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX63B68467628545448952CADE96EB1C07">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ToolTip</string>
										<string name="ScriptGuid">{4FFF482F-D13B-4689-9C3F-AF3CC373562A}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local UIPresetsConfig = TS.import(script, script.Parent.Parent, "UIPresetsConfig").UIPresetsConfig
local BoundCheck = TS.import(script, script.Parent, "BoundCheck").BoundCheck
local TextService = game:GetService("TextService")
local UserInputService = game:GetService("UserInputService")
--* The {@link ToolTip} options that change default behavior. 
--[[
	*
	 * This is a component that will create a ToolTip near the target element.
	 
]]
local ToolTip
do
	ToolTip = setmetatable({}, {
		__tostring = function()
			return "ToolTip"
		end,
	})
	ToolTip.__index = ToolTip
	function ToolTip.new(...)
		local self = setmetatable({}, ToolTip)
		return self:constructor(...) or self
	end
	function ToolTip:constructor(text, targetElement)
		self.Options = {
			FollowMouse = false,
		}
		self.TextSize = 18
		self.Text = text
		self.TargetElement = targetElement
		-- Get the initial absolute size based on starting text
		self:_updateTextBounds()
		local tl = Instance.new("TextLabel")
		tl.Name = `Tooltip-{self.TargetElement.Name}`
		tl.Size = UDim2.new(0, self._absSize.X, 0, self._absSize.Y)
		tl.AnchorPoint = Vector2.new(0.5, 0.5)
		tl.Text = text
		self._tooltipLabel = tl
		self._boundCheck = BoundCheck.new(targetElement)
		self._boundCheck.BoundEnter:Connect(function()
			self:Draw()
		end)
		self._boundCheck.BoundExit:Connect(function()
			self._tooltipLabel.Parent = nil
		end)
	end
	function ToolTip:SetText(text)
		self.Text = text
		self:_updateTextBounds()
		self._tooltipLabel.Text = text
	end
	function ToolTip:SetPosition(pos)
		if pos == nil then
			pos = UserInputService:GetMouseLocation()
		end
		local label = self._tooltipLabel
		local halfAbsSize = Vector2.new(label.AbsoluteSize.X / 2, label.AbsoluteSize.Y / 2)
		local screenSize = ToolTip._tooltipSG.AbsoluteSize
		local isOverLeft = (pos.X - halfAbsSize.X) < 0
		local isOverRight = (pos.X + halfAbsSize.X) > screenSize.X
		local isOverTop = (pos.Y - halfAbsSize.Y) < 0
		local isOverBottom = (pos.Y + halfAbsSize.Y) > screenSize.Y
		-- Adjust the current position by the size to be within screen
		local adjustedPos = UDim2.fromOffset(pos.X, pos.Y)
		if isOverLeft then
			local _adjustedPos = adjustedPos
			local _arg0 = UDim2.fromOffset(halfAbsSize.X, 0)
			adjustedPos = _adjustedPos + _arg0
		end
		if isOverRight then
			local _adjustedPos = adjustedPos
			local _arg0 = UDim2.fromOffset(halfAbsSize.X, 0)
			adjustedPos = _adjustedPos - _arg0
		end
		if isOverTop then
			local _adjustedPos = adjustedPos
			local _arg0 = UDim2.fromOffset(halfAbsSize.Y, 0)
			adjustedPos = _adjustedPos + _arg0
		end
		if isOverBottom then
			local _adjustedPos = adjustedPos
			local _arg0 = UDim2.fromOffset(halfAbsSize.Y, 0)
			adjustedPos = _adjustedPos - _arg0
		end
		label.Position = adjustedPos
	end
	function ToolTip:Draw()
		-- Size the ToolTip element before positioning
		self._tooltipLabel.Size = UDim2.new(0, self._absSize.X, 0, self._absSize.Y)
		-- Update the Position
		self:SetPosition()
		self._tooltipLabel.Parent = ToolTip._tooltipSG
	end
	function ToolTip:Destroy()
		self._boundCheck:Destroy()
		self._boundCheck = nil
		self._tooltipLabel:Destroy()
		self._tooltipLabel = nil
		self.TargetElement = nil
	end
	function ToolTip:_updateTextBounds()
		local _exp = TextService:GetTextSize(self.Text, self.TextSize, Enum.Font.Roboto, Vector2.new(ToolTip._tooltipSG.AbsoluteSize.X * 0.4, ToolTip._tooltipSG.AbsoluteSize.Y * 0.3))
		local _vector2 = Vector2.new(1, 1)
		self._absSize = _exp + _vector2
	end
	ToolTip._tooltipSG = Instance.new("ScreenGui")
	do
		ToolTip._tooltipSG.Name = "UIPresets_ToolTip"
		ToolTip._tooltipSG.IgnoreGuiInset = true
		ToolTip._tooltipSG.ResetOnSpawn = false
		ToolTip._tooltipSG.DisplayOrder = UIPresetsConfig.HighestDisplayOrder + 1
		ToolTip._tooltipSG.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
		-- When the HighestDisplayOrder is changed update the ContextMenuSG DisplayOrder
		UIPresetsConfig.OnDisplayOrderChanged:Connect(function(newOrder)
			local _exp = ToolTip._tooltipSG
			_exp.DisplayOrder = newOrder + 1
			return _exp.DisplayOrder
		end)
	end
end
return {
	ToolTip = ToolTip,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb5</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX4605E4DBAD7C4B3DA680D5805538ADC5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">SettingsCreator</string>
										<string name="ScriptGuid">{2DF7EFFD-B4B9-4406-AA21-937505374741}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
--[[
	*
	 * This is a class designed to ease the creation of a settings UI panel. It supports default Roblox GuiObject's.
	 
]]
local SettingsCreator
do
	SettingsCreator = setmetatable({}, {
		__tostring = function()
			return "SettingsCreator"
		end,
	})
	SettingsCreator.__index = SettingsCreator
	function SettingsCreator.new(...)
		local self = setmetatable({}, SettingsCreator)
		return self:constructor(...) or self
	end
	function SettingsCreator:constructor()
		-- Use the defined setting template to create this settings object
	end
end
return {
	SettingsCreator = SettingsCreator,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000076ab</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBXB774170B5AFA481DA6A942803AFE4F80">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">SettingsTemplate</string>
											<string name="ScriptGuid">{A2394136-47BE-49CA-BF5B-3F5B5CE01A4F}</string>
											<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local SettingsTemplate
do
	SettingsTemplate = setmetatable({}, {
		__tostring = function()
			return "SettingsTemplate"
		end,
	})
	SettingsTemplate.__index = SettingsTemplate
	function SettingsTemplate.new(...)
		local self = setmetatable({}, SettingsTemplate)
		return self:constructor(...) or self
	end
	function SettingsTemplate:constructor()
	end
end
return {
	SettingsTemplate = SettingsTemplate,
}
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000076ac</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXDD28E7BAC3EA486CB14F689D47D7F2E0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">presets</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb6</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXA0A30E2560B145689008C7BB6DCC2EE3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Placeholder</string>
										<string name="ScriptGuid">{7408A3B3-4839-4E39-AEF7-4120A4D41FA0}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
return nil
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb7</UniqueId>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXFA61F58A56F74DA2B188C005122A4D13">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">settings</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb8</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBX5BBCF1BC6988449481C4DCC25486CDB6">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">TickSetting</string>
											<string name="ScriptGuid">{5B6990CC-464D-4DC1-A504-17FAA3818D5D}</string>
											<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
--[[
	*
	 * The TickSetting type that this setting will contain either a Check for a checkmark or a cross as a mark.
	 * @enum
	 
]]
local TickSettingType
do
	local _inverse = {}
	TickSettingType = setmetatable({}, {
		__index = _inverse,
	})
	TickSettingType.Cross = 0
	_inverse[0] = "Cross"
	TickSettingType.Check = 1
	_inverse[1] = "Check"
end
local IMAGE_CROSS = "6031094678"
local IMAGE_CHECK = "6031094667"
local ContentProvider = game:GetService("ContentProvider")
--[[
	*
	 * This is a Setting preset that creates a label and a button which as of now can be a croos or a check image.
	 
]]
local TickSetting
do
	TickSetting = setmetatable({}, {
		__tostring = function()
			return "TickSetting"
		end,
	})
	TickSetting.__index = TickSetting
	function TickSetting.new(...)
		local self = setmetatable({}, TickSetting)
		return self:constructor(...) or self
	end
	function TickSetting:constructor(_type, name, tickedByDefault)
		if tickedByDefault == nil then
			tickedByDefault = false
		end
		self._type = _type
		self.IsTicked = tickedByDefault
		self.Name = name
		local frame = Instance.new("Frame")
		frame.Name = `TickSetting-{name}`
		frame.Size = UDim2.new(1, 0, 0.1, 0)
		local label = Instance.new("TextLabel")
		label.Name = `Label-{name}`
		label.Text = name
		label.Size = UDim2.new(0.4, 0, 1, 0)
		label.TextScaled = true
		label.Parent = frame
		local textConstraint = Instance.new("UITextSizeConstraint")
		textConstraint.MaxTextSize = 20
		textConstraint.MinTextSize = 10
		textConstraint.Parent = label
		local btn = Instance.new("ImageButton")
		btn.ImageTransparency = if tickedByDefault then 0 else 1
		btn.Name = `Button-{name}`
		btn.Size = UDim2.new(0.6, 0, 1, 0)
		btn.Position = UDim2.new(0.4, 0, 0, 0)
		btn.Image = if self._type == TickSettingType.Cross then IMAGE_CROSS else IMAGE_CHECK
		btn.Parent = frame
		local aspectRatio = Instance.new("UIAspectRatioConstraint")
		aspectRatio.DominantAxis = Enum.DominantAxis.Height
		aspectRatio.AspectRatio = 1
		aspectRatio.Parent = btn
		self.Label = label
		self.TickBtn = btn
		self.Frame = frame
		self._tickBtnConnection = btn.MouseButton1Click:Connect(function()
			local isTicked = not self.IsTicked
			self.TickBtn.ImageTransparency = if isTicked then 0 else 1
			self.IsTicked = isTicked
		end)
	end
	function TickSetting:Destroy()
		self.Label = nil
		self.TickBtn = nil
		self.Frame = nil
		if self._tickBtnConnection then
			self._tickBtnConnection:Disconnect()
			self._tickBtnConnection = nil
		end
	end
	do
		-- Preload these image ids
		TS.Promise.defer(function()
			return ContentProvider:PreloadAsync({ IMAGE_CROSS, IMAGE_CHECK })
		end)
	end
end
return {
	TickSetting = TickSetting,
	TickSettingType = TickSettingType,
}
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">4665e33cded9312a070d123c00007cb9</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXE872B704A55B49BDA44D1A4FB9EBB58A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">buttons</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000076b1</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBX3BFC295496204B3490C0E6BCFC525609">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">CloseBtn</string>
											<string name="ScriptGuid">{AE6538EF-A990-4965-ACA2-0490BC16F683}</string>
											<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local PresetsData = TS.import(script, script.Parent.Parent.Parent, "PresetsData").PresetsData
local ECloseBtnAttributes = {
	TintEnabled = "TintEnabled",
	TintColor = "TintColor",
}
--[[
	*
	 * The attributes that belong to preset
	 
]]
local DEFAULT_TINT = Color3.fromRGB(255, 0, 0)
local function createCloseButton()
	local CloseBtn = Instance.new("ImageButton")
	CloseBtn.AnchorPoint = Vector2.new(1, 0.5)
	CloseBtn.AutoButtonColor = false
	CloseBtn.BackgroundColor3 = Color3.fromRGB(66, 66, 66)
	CloseBtn.BorderSizePixel = 0
	CloseBtn.Image = "http://www.roblox.com/asset/?id=6031094678"
	CloseBtn.LayoutOrder = -1
	CloseBtn.Name = "CloseBtn"
	CloseBtn.Position = UDim2.new(1, 0, 0.5, 0)
	CloseBtn.ScaleType = Enum.ScaleType.Fit
	CloseBtn.Size = UDim2.new(0, 0, 0.6, 0)
	CloseBtn.ZIndex = -1
	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.AspectType = Enum.AspectType.ScaleWithParentSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = CloseBtn
	local Tint = Instance.new("Frame")
	Tint.BackgroundColor3 = DEFAULT_TINT
	Tint.BackgroundTransparency = 0.8
	Tint.BorderSizePixel = 0
	Tint.Name = "Tint"
	Tint.Size = UDim2.new(1, 0, 1, 0)
	Tint.Visible = false
	Tint.Parent = CloseBtn
	return CloseBtn
end
--[[
	*
	 * This is the close button preset, it it a ImageButton that defaults to an 'X' cross image with a default
	 * 'Red' tint, this can be overridden inside {@link PresetsData.Attributes}, see {@link CloseBtnAttributes}
	 * for this presets attributes.
	 
]]
local CloseBtn
do
	local super = PresetsData
	CloseBtn = setmetatable({}, {
		__tostring = function()
			return "CloseBtn"
		end,
		__index = super,
	})
	CloseBtn.__index = CloseBtn
	function CloseBtn.new(...)
		local self = setmetatable({}, CloseBtn)
		return self:constructor(...) or self
	end
	function CloseBtn:constructor()
		local closeBtn = createCloseButton()
		super.constructor(self, closeBtn)
		self._tintFrame = closeBtn:WaitForChild("Tint")
		self.Attributes = {
			PresetUUID = self.Attributes.PresetUUID,
			TintEnabled = true,
			TintColor = DEFAULT_TINT,
		}
		self:InitAttributes()
		-- Assign attribute handlers after everything is finalized
		self:AttachAttributeHandler(ECloseBtnAttributes.TintEnabled, function(enabled)
			self._tintFrame.Visible = if enabled then true else false
		end)
		self:AttachAttributeHandler(ECloseBtnAttributes.TintColor, function(color)
			self._tintFrame.BackgroundColor3 = if color then color else DEFAULT_TINT
		end)
	end
	function CloseBtn:Destroy()
		super.Destroy(self)
	end
end
return nil
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000076b2</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXC518DDB71A904627827DD89539ACBAFD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">PresetsData</string>
									<string name="ScriptGuid">{067626BE-2CEB-4D61-850A-435D52862335}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "@rbxts", "object-utils"))
local HttpService = game:GetService("HttpService")
--[[
	*
	 * The attribute enum items for the data attributes, this is simply for simpler usage.
	 * @enum
	 
]]
--* This is the base data attributes that are attached to the preset Instance. 
--* The structure of the attribute handler function. 
local function generateDefaultAttributes()
	return {
		PresetUUID = "",
	}
end
--[[
	*
	 * This class represents the core base data for all UIPresets 'presets'.
	 * **NOTE:** Remember to call {@link InitAttributes} before attaching the handlers in the derived class.
	 * @typeParam A - The attributes structure that extends from PresetsDataAsstributes.
	 
]]
local PresetsData
do
	PresetsData = setmetatable({}, {
		__tostring = function()
			return "PresetsData"
		end,
	})
	PresetsData.__index = PresetsData
	function PresetsData.new(...)
		local self = setmetatable({}, PresetsData)
		return self:constructor(...) or self
	end
	function PresetsData:constructor(owner)
		self._attachedHandlers = {}
		local uuid = HttpService:GenerateGUID(false)
		local __storedPresetsData = PresetsData._storedPresetsData
		local _uuid = uuid
		if __storedPresetsData[_uuid] ~= nil then
			uuid = HttpService:GenerateGUID(false)
		end
		self.Attributes = generateDefaultAttributes()
		self.Attributes.PresetUUID = uuid
		self._owner = owner
		-- When the attributes are changed update the internal attributes
		self._owner.AttributeChanged:Connect(function(attr)
			local currentValue = self._owner:GetAttribute(attr)
			if self.Attributes[attr] ~= nil then
				(self.Attributes)[attr] = currentValue
			end
			-- Call the attribute handler for this attribute to relay changes
			local __attachedHandlers = self._attachedHandlers
			local _attr = attr
			local changedHandler = __attachedHandlers[_attr]
			if changedHandler then
				changedHandler(currentValue)
			end
		end)
		local __storedPresetsData_1 = PresetsData._storedPresetsData
		local _uuid_1 = uuid
		local _self = self
		__storedPresetsData_1[_uuid_1] = _self
	end
	function PresetsData:SetAttribute(key, value)
		local _value = self.Attributes[key]
		if _value ~= 0 and _value == _value and _value ~= "" and _value then
			local attr = self._owner:GetAttribute(key)
			-- If the attribute doesn't exist and the value is undefined or null, don't create the attribute.
			if not (attr ~= 0 and attr == attr and attr ~= "" and attr) then
				return nil
			end
			self._owner:SetAttribute(key, value)
		end
	end
	function PresetsData:Destroy()
		local __storedPresetsData = PresetsData._storedPresetsData
		local _presetUUID = self.Attributes.PresetUUID
		__storedPresetsData[_presetUUID] = nil
		table.clear(self._attachedHandlers)
		self._attachedHandlers = nil
		self._owner:Destroy()
		self._owner = nil
	end
	function PresetsData:AttachAttributeHandler(key, handler)
		local _key = key
		if typeof(_key) ~= "string" then
			return nil
		end
		-- If it's not a recognized attribute, return
		local _value = self.Attributes[key]
		if not (_value ~= 0 and _value == _value and _value ~= "" and _value) then
			return nil
		end
		local __attachedHandlers = self._attachedHandlers
		local _key_1 = key
		local _handler = handler
		__attachedHandlers[_key_1] = _handler
		handler(self.Attributes[key])
	end
	function PresetsData:DeattachAttributeHandler(key)
		local _key = key
		if typeof(_key) ~= "string" then
			return nil
		end
		local __attachedHandlers = self._attachedHandlers
		local _key_1 = key
		__attachedHandlers[_key_1] = nil
	end
	function PresetsData:InitAttributes()
		for _, _binding in Object.entries(self.Attributes) do
			local key = _binding[1]
			local value = _binding[2]
			local attr = self._owner:GetAttribute(key)
			if attr == nil then
				self._owner:SetAttribute(key, value)
			else
				self.Attributes[key] = attr
			end
		end
	end
	PresetsData._storedPresetsData = {}
end
return {
	PresetsData = PresetsData,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000076b4</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXEC866F4B960E420BAB1AE58AC6269F42">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">object-utils</string>
								<string name="ScriptGuid">{2C28F065-9142-489C-88F3-14278A9985CC}</string>
								<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Object = {}

function Object.keys(object)
	local result = table.create(#object)
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function Object.values(object)
	local result = table.create(#object)
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function Object.entries(object)
	local result = table.create(#object)
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function Object.assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

function Object.copy(object)
	local result = table.create(#object)
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = table.create(#object)
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

function Object.deepCopy(object)
	return deepCopyHelper(object, {})
end

function Object.deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = Object.deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(data)
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.fromEntries(entries)
	local entriesLen = #entries

	local result = table.create(entriesLen)
	if entries then
		for i = 1, entriesLen do
			local pair = entries[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

return Object
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000076af</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB2C4DFBDCA01442EB24FB24096684356">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">events</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">14c2b1ffe8940d050712d29100008594</UniqueId>
				</Properties>
				<Item class="BindableEvent" referent="RBX5D8CA923AADD43F7B011499C11CBF737">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">CreatePreset</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">14c2b1ffe8940d050712d29100008597</UniqueId>
					</Properties>
				</Item>
				<Item class="BindableEvent" referent="RBXECD73D76FA504D6389E1D644678DAE4A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">14c2b1ffe8940d050712d29100008597</UniqueId>
						<string name="Name">CreateComponent</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">14c2b1ffe8940d050712d29100008598</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBXE64C2B42800E4152B8494EFCC19C0DAA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000034e</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX01ED90E342964EC3A4A4B09E9CC3E3D9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000003e9d</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBXF0A43C0E6A324C2CA27B3CBE6D0EB4B5">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"><![CDATA[BAAAABQAAABSQlhfQmFja3VwQnJpZ2h0bmVzcwUAAIA/HgAAAFJCWF9CYWNrdXBFeHBvc3Vy
ZUNvbXBlbnNhdGlvbgUAAAAAIQAAAFJCWF9MaWdodGluZ0NvbXBhdGliaWxpdHlNaWdyYXRl
ZAMBIAAAAFJCWF9PcmlnaW5hbFRlY2hub2xvZ3lPbkZpbGVMb2FkBAEAAAA=]]></BinaryString>
			<float name="Brightness">1.98124921</float>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="DefinesCapabilities">false</bool>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="Intent">0</token>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<token name="Quality">1</token>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f00000037f</UniqueId>
		</Properties>
		<Item class="ColorGradingEffect" referent="RBX356D82F5C1F548EEBC7C3D7EF27BCFF3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ColorGrading</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<token name="TonemapperPreset">1</token>
				<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000005ee</UniqueId>
			</Properties>
		</Item>
		<Item class="BloomEffect" referent="RBXCD49812BB58249A4B79D83CCE5E141FF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="Intensity">0</float>
				<string name="Name">Bloom</string>
				<float name="Size">24</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="Threshold">0.949999988</float>
				<UniqueId name="UniqueId">14c2b1ffe8940d050712d291000005ef</UniqueId>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX096F15AB57294FEEA76641A65F8E6E37">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">UIPresetsBG.d.ts</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{3D2CAA0C-E0E6-41C6-B189-ACDDFBBE7C70}</string>
				<ProtectedString name="Source"><![CDATA[type UIPresetsBG = Frame & {
	SettingsBtn: ImageButton & {
		UIAspectRatioConstraint: UIAspectRatioConstraint;
	};
	Content: Frame & {
		["NavItem-Main"]: Frame & {
			Content: Frame;
		};
	};
	Title: TextLabel & {
		UICorner: UICorner;
		UITextSizeConstraint: UITextSizeConstraint;
	};
	NavbarBG: Frame & {
		Navbar: ScrollingFrame & {
			ComponentsBtn: TextButton & {
				UITextSizeConstraint: UITextSizeConstraint;
				UIAspectRatioConstraint: UIAspectRatioConstraint;
				UIPadding: UIPadding;
			};
			PresetsBtn: TextButton & {
				UITextSizeConstraint: UITextSizeConstraint;
				UIAspectRatioConstraint: UIAspectRatioConstraint;
				UIPadding: UIPadding;
			};
			UIListLayout: UIListLayout;
		};
	};
}
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">0dfe7783ff23269307157c5d00007391</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="LodDataService" referent="RBXEDC6358150A14FADA777286BC5B3E2A3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LodDataService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000000382</UniqueId>
		</Properties>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBX2E747C955A8E4BD4AFA5A91B014DF636">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000003cd6</UniqueId>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXEA8894FBC6C940C58243BB928865CAD5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000003eaa</UniqueId>
		</Properties>
	</Item>
	<Item class="UGCAvatarService" referent="RBX065FC222494E4638BD5D8388EAAFE55D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">UGCAvatarService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000003eb0</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBXB39096F9D3054785AFA62C6B8B7D771A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000003eb8</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBXEDC17F672AB64D0E88A1FAE8DA61E0FA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Enabled">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f0000043c8</UniqueId>
		</Properties>
	</Item>
	<Item class="DataStoreService" referent="RBX820DC568610D404995BF52E5037EB95F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutomaticRetry">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f0000045a4</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBX6897FB39C6434ADC90890B3291177F76">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7889031309ed50d5060a27f000004d16</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>